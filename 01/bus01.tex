\documentclass[a4paper,graphics,11pt]{article}
\pagenumbering{arabic}

\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{amsmath, tabu}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage{mathtools}
\usepackage{setspace}
\usepackage{graphicx,color,curves,epsf,float,rotating}
\usepackage{tasks}
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\newcommand{\aufgabe}[1]{\subsection*{Aufgabe #1}}
\newcommand{\up}[2]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny #2}}}{#1}}}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=Java,
    aboveskip=2mm,
    belowskip=2mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    literate={ä}{{\"a}}1 {Ä}{{\"A}}1 {ö}{{\"o}}1 {Ö}{{\"O}}1 {ü}{{\"u}}1 {Ü}{{\"U}}1 {ß}{{\ss}}1
}

\begin{document}
\noindent Gruppe \fbox{\textbf{20}}             \hfill Patrick Arens, 377536\\
\noindent Betriebssysteme und Systemsoftware    \hfill Georg Manthey 376854\\
\strut\hfill Benedikt Gerlach, 376944\\
\begin{center}
	\LARGE{\textbf{Übung 1}}
\end{center}
\begin{center}
\rule[0.1ex]{\textwidth}{1pt}
\end{center}

\aufgabe{1.1}
\textbf{a)}

\begin{verbatim}
echo "BuS 2016: Abgabe der 1. Uebung am 6.5" | sed -e s/6/7/
\end{verbatim}

\textbf{b)}

Der Befehl gibt von jeder Zeile der Datei \textit{d*} das erste Wort, also alles was vor dem ersten Leerzeichen jeder Zeile steht, aus. \textit{-d ' '} beschreibt dabei, welches zeichen als Trennzeichen verwendet wird, der Text wird also als eine Tabelle aufgefasst wobei jedes Leerzeichen in einer Zeile für eine weitere Spalte steht. Nun beschreibt \textit{-f 1}, dass die erste Spalte ausgegeben werden soll, also das erste Wort. Das \textit{d*} am Ende beschreibt die Datei, aus welcher die Information gelesen werden soll.


\textbf{c)}

Der Befehl :

\begin{verbatim}
grep -A3 -E ^[[:alpha:]]\+[[:space:]]\+[[:alpha:]]\+$ emails 
| grep -B1 -A1 -E ^[[:alpha:]]\+[[:space:]]\+[[:digit:]]\+$
\end{verbatim}



Erkennt die Adresse:

Arthur Dent\\
Galaxy 7\\
74369 Third Orbit

Welche sich in den Zeilen 10034 bis 19036 befindet. Die E-Mail wurde von realArthurDent@posteo.de verschickt und von emily.saunders@mostlyharmless.com erhalten.\\

\newpage

\aufgabe{1.2}
\textbf{a)}

\begin{verbatim}
tr -d '"?.!:;,+\&‘' < wotw.txt > wotwNeu.txt
tr -s " " < wotwNeu.txt > wotwNeu2.txt
\end{verbatim}

Zeile 1: Entfernt alle " ? . ! : ; , +  \& ‘  und speichert die Datei unter wotwNeu.txt\\
Zeile 2: Entfernt alle sich wiederholenden Leerzeichen aus wotwNeu.txt und speichert die Datei unter wotwNeu2.txt\\


\textbf{b)}

\begin{verbatim}
tr ' ' '\n' < wotw.txt | grep road | wc -l
\end{verbatim}



Das Ergebnis ist 122.

\textbf{c)}

\begin{verbatim}
tr -c '[:alnum:]' '[\n*]' < wotw.txt | sort | uniq -c | sort -nr | head  -10
\end{verbatim}


Das Ergebnis ist 12223 absolute Häufigkeit, 4417 the, 2373 and, 2284 of, 1554 a, 1300 I, 1160 to, 924 in, 853 was und 754 that.

\aufgabe{1.3}
\textbf{a)}

Ein Systemcall bzw. Syscall ist eine Methode um vom Betriebssystem bereitgestellte Funktionalitäten auszuführen, wie zum Beispiel das Schreiben einer Datei. Dabei wird die Kontrolle vom Programm an den Kernel übergeben.

\textbf{b)}

\textit{execve} = Ausführen einer ausführbaren Datei (z.B. .out Datei) oder interpretieren der Datei durch in der Datei definierten Interpreter.

\textit{open} = Aufruf einer Datei File Management

\textit{stat} = Status einer Datei oder eines Dateisystems anzeigen (Speicherverbrauch, Zugriffzeitpunkt... ).

\textit{mmap} = Bildet eine Datei oder ein Gerät im virtuellen Speicher ab. (ka ob das so stimmt...)


\textbf{c)}

\textit{strace} = diagnostic tool welchen den Prozess mit dem es gestartet wurde überwacht und alle syscalls die es aufruft speichert.

\textbf{d)}
\textbf{TODO}

strace ls /etc -C -e trace=execve,stat,lstat,fstat,open,openat,getdents,readdir

strace ls -l /etc -C -e trace=execve,stat,lstat,fstat,open,openat,getdents,readdir

(weiterleitung der ausgabe mit > )

\aufgabe{1.4}

\textbf{a)}

\textit{str[1] = ’0’;} $\Longrightarrow$ setzt den zweiten Eintrag des char Arrays str auf 0. str hat nun die werte 103.

\textbf{b)}

\textit{i = *(list + 3);} $\Longrightarrow$ setzt den wert von list[3] auf 7

\textbf{c)}

\textit{pi =  \&list[i];} $\Longrightarrow$ Durch den Befehl wird versucht den Zeiger pi auf den int wert von list[7] zu zeigen. Da list aber nur 4 Elemente hat ist dieser Befehl nicht möglich.

\textbf{d)}

\textit{*pi = 42;} $\Longrightarrow$ Auf den Speicherbereich auf den pi zeigt soll der int wert 42 geschrieben werden. Da pi aber noch nicht initialisiert ist, könnte der Compiler einen Fehler werfen.

\textbf{e)}

\textit{list = pi;} $\Longrightarrow$ Durch diesen Befehl soll die Basisadresse von list auf die Adresse auf die der Zeiger von pi zeigt gelegt werden, da das Array nun aber keinen zusammenhängenden Speicherbereich mehr hat ist das ein Fehler.

\textbf{f)}

\textit{i = *(pi + 2);} $\Longrightarrow$ Da pi immer noch nicht initialisiert ist, ist es unklar worauf pi zeigt. Demnach ist der Zuweisung auf den 2 Speicherbereich nach pi nicht möglich.

\textbf{g)}

\textit{str[3]=’4’;} $\Longrightarrow$ Das char-Array str wird an der Stelle mit dem Index 3 um das Zeichen 4 erweitert. str hat jetzt den Wert 1034.

\newpage

\aufgabe{1.5}

\textbf{a)}

Rundungsproblem float zu int.

\textbf{b)}\\

\lstinputlisting{1.5d.txt}

\textbf{c)}

Es ist möglich das Programm ohne explizite Typkonvertierung zu lösen indem man 9/5 durch 1.8 ersetzt.

\aufgabe{1.6}

\textbf{3.} b zeigt vor dem Aufruf auf a[0]. Durch b++; zeigt b nun auf a[1].

\textbf{4.} t1 wird der Wert zugewiesen der in der Speicheradresse von b steht. Also wir t1 = 11. (Dereferenzierung)

\textbf{5.} Der Pointervariable c wird die Speicheradresse von b zugewiesen. (Referenzierung)

\textbf{6.} c erhält den Wert der in der Speicheradresse steht und erhöht ihm um zwei. Nun hat das Array folgende Einträge a[]={2,13,23,42,13,37}. (2x Dereferenzierung)

\textbf{7.} c erhält den wert 13, demnach erhält t2 den Wert 14.(2x Dereferenzierung)

\textbf{8.} **c zeigt auf a[1]=13 und a[3]=42, demnach ist t3 = 42\&13. Der \& operator ist in diesem Fall ein bitweises UND. Somit ist t3 = 8.

\textbf{9.} b zeigt nun auf a[5], weil b = a+5 $\Longleftrightarrow$ b = \&a[5].

\textbf{10.} Da b auf a[5] zeigt wird a[5] auf 10 gesetzt. Nun hat das Array folgende Einträge a[]={2,13,23,42,13,10}.

\end{document}
\grid
